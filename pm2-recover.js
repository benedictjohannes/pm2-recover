#!/usr/bin/env node
const path = require('path')
const fs = require('fs')
const os = require('os')

// --- Help Text ---
const PM2_DUMP_PATH_TILDE = path.join('~', '.pm2', 'dump.pm2') // For display only
const helpText = `
PM2 Recovery Shell Command Generator

Description:
  Generates shell commands to recreate PM2 processes based on pm2 dump file, 
  correcting for environmental changes (like NVM version switching).
  Useful to recreate numerous PM2 processes when path to Node executables change (eg using nvm)

Usage:
  node pm2-recover.js [OPTIONS]
  npx pm2-recover [OPTIONS]

Options:
  -f, --dumpFile <path>   Specify a custom PM2 dump file path.
                          (Default: ${PM2_DUMP_PATH_TILDE})
  -o, --outFile <path>    Write generated commands to a file instead of stdout.
  -h, --help              Show this help message.

Features:
  - Preserves process status: Processes originally 'stopped' are started then immediately stopped.
  - Preserves watch mode: The --watch flag is added if defined in the original configuration.
  - Corrects NVM paths: Switches old absolute Node paths to generic commands for environment flexibility.

Example:
  # Generate commands from a custom dump file and save for review
  node recover.js -f /tmp/backup.json -o relaunch_script.sh

  # Generate commands from default dump and pipe to bash (use caution!)
  node recover.js | bash
`

// --- Argument Parsing ---
// Custom parser to support both space-separated and equal-sign syntax
const rawArgs = process.argv.slice(2)
const args = {}

for (let i = 0; i < rawArgs.length; i++) {
    const arg = rawArgs[i]
    let key = null
    let value = null

    if (arg.startsWith('--')) {
        // Long flag: --key=value or --key value
        ;[key, value] = arg.substring(2).split('=')
        if (!value && rawArgs[i + 1] && !rawArgs[i + 1]?.startsWith('-')) {
            // Check for space-separated value
            value = rawArgs[i + 1]
            i++ // Consume the next argument
        }
    } else if (arg.startsWith('-') && arg.length > 1) {
        // Short flag: -k value or -k=value
        key = arg.substring(1)

        // Handle -k=value
        if (key.includes('=')) {
            ;[key, value] = key.split('=')
        }

        // Handle -k value
        if (!value && rawArgs[i + 1] && !rawArgs[i + 1]?.startsWith('-')) {
            value = rawArgs[i + 1]
            i++ // Consume the next argument
        }
    }
    if (key) {
        // Map short flags to long flags internally
        const mappedKey =
            {
                f: 'dumpFile',
                o: 'outFile',
                h: 'help',
            }[key] || key

        args[mappedKey] = value === undefined ? true : value
    }
}

// --- Configuration & Defaults ---

const PM2_DUMP_PATH = path.join(os.homedir(), '.pm2', 'dump.pm2')

// Default input/output settings
const INPUT_FILE = args.dumpFile || PM2_DUMP_PATH
const OUTPUT_FILE = args.outFile || null
const REQUIRED_KEYS = ['name', 'pm_cwd', 'pm_exec_path']

let outputText = ''

// --- Help Function ---

if (Object.prototype.hasOwnProperty.call(args, 'help')) {
    console.info(helpText)
    process.exit(0)
}

// --- Helper Functions ---

function escapeShellCommand(cmd) {
    return cmd.replace(/'/g, "'\\''")
}

function formatArgs(args) {
    if (!args || args.length === 0) {
        return ''
    }
    return args.map(arg => `'${escapeShellCommand(arg)}'`).join(' ')
}

function checkDumpContent(processes) {
    if (!Array.isArray(processes) || processes.length === 0) {
        throw new Error(
            'Dump content is empty or not a valid array of processes.'
        )
    }

    processes.forEach((proc, index) => {
        REQUIRED_KEYS.forEach(key => {
            if (
                !Object.prototype.hasOwnProperty.call(proc, key) ||
                !proc[key]
            ) {
                throw new Error(
                    `Process #${index} (Name: ${
                        proc.name || 'N/A'
                    }) is missing required key: ${key}`
                )
            }
        })
    })
    return true
}

// --- Main Generation Logic ---

function generateCommands(processes) {
    const configPath = path.resolve(INPUT_FILE)

    outputText += '#!/bin/bash\n'
    outputText += '# --- PM2 Relaunch Commands Generated by Node.js ---\n'
    outputText += `# Input File: ${configPath}\n`
    outputText +=
        '# Structure: pm2 start --name NAME COMMAND [OPTIONS] -- ARGS\n\n'
    outputText +=
        '# Sets bash to stop script execution immediately after error\n'
    outputText += 'set -euo pipefail\n'
    outputText += `# Execute pm2 kill first to ensure pm2 is processes would be created fresh, skip this line if you don't need to.\n`
    outputText += 'pm2 kill\n'

    processes.forEach(proc => {
        const { args, name, pm_cwd, pm_exec_path, status, watch } = proc

        const dir = pm_cwd
        let targetCommand
        let commandArgs = []
        let pm2Options = []

        // 1. WATCH parameter check
        if (watch) {
            pm2Options.push('--watch')
        }

        // 2. SHELL-WRAPPED COMMANDS (Pattern A)
        if (args && args[0] === '-c') {
            const commandString = args[1]
            const quotedCommand = `'${escapeShellCommand(commandString)}'`

            outputText += `\n# [Shell-Wrapped] Process: ${name}\n`
            outputText += `cd "${dir}" && pm2 start --name ${name} ${pm2Options.join(
                ' '
            )} ${quotedCommand}\n`
        } else {
            // 3. DIRECT EXECUTION COMMANDS (Patterns B & C)

            if (!args || args.length === 0) {
                targetCommand = pm_exec_path
            } else {
                // Pattern B: npx/npm/etc. managed by old nvm path.
                const nvmDir = process.env.NVM_DIR
                const isNvmPath =
                    (nvmDir && pm_exec_path.includes(nvmDir)) ||
                    pm_exec_path.includes(path.join('nvm', 'versions', 'node'))

                if (pm_exec_path && isNvmPath) {
                    targetCommand = args[0]
                    commandArgs = args.slice(1)
                }
                // Pattern C: Custom Binary or generic direct execution.
                else {
                    targetCommand = pm_exec_path || args[0]
                    commandArgs = pm_exec_path ? args : args.slice(1)

                    if (pm_exec_path && pm_exec_path.startsWith(dir)) {
                        targetCommand =
                            '.' + path.sep + path.basename(pm_exec_path)
                    }
                }
            }

            const formattedArgs = formatArgs(commandArgs)
            const argsFlag = formattedArgs ? ` -- ${formattedArgs}` : ''

            outputText += `\n# [Direct Exec] Process: ${name}\n`
            outputText += `cd "${dir}" && pm2 start --name ${name} ${pm2Options.join(
                ' '
            )} '${targetCommand}'${argsFlag}\n`
        }

        // 4. STATUS check: If originally stopped, stop it after starting.
        if (status === 'stopped') {
            outputText += `pm2 stop ${name}\n`
        }
    })

    outputText += '\n# --- FINALIZATION ---\n'
    outputText += 'pm2 save\n'
    outputText += 'pm2 list\n'
}

// --- Execution ---

try {
    const data = fs.readFileSync(INPUT_FILE, 'utf8')
    const processes = JSON.parse(data)

    checkDumpContent(processes)
    generateCommands(processes)

    if (OUTPUT_FILE) {
        fs.writeFileSync(OUTPUT_FILE, outputText)
        console.info(
            `\nâœ… Success: PM2 restart commands written to ${path.resolve(
                OUTPUT_FILE
            )}`
        )
        console.info(`\nRun: bash ${path.resolve(OUTPUT_FILE)}`)
    } else {
        console.info(outputText)
    }
} catch (error) {
    console.error(`\n--- EXECUTION ERROR ---`)
    if (error.code === 'ENOENT') {
        console.error(`File not found: ${path.resolve(INPUT_FILE)}`)
        console.error(
            `If running default, ensure PM2 has run 'pm2 save' at least once.`
        )
    } else {
        console.error(`Error processing file: ${error.message}`)
    }
    process.exit(1)
}
